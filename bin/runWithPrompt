#!/bin/bash

printShortUsage()
{
    printf 'Usage: echo COMMANDS | %q %s\n' "$(basename "$1")" '[--trailing-prompt|--no-trailing-prompt] [--emulate-prompt] [--worst-status] [-c|--comment COMMENT] [-?|-h|--help]'
    printf 'Usage: %q %s <<EOF\n  COMMANDS\nEOF\n' "$(basename "$1")" '[...]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Run the COMMANDS read from stdin, each surrounded by an (emulated) command prompt.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --trailing-prompt	Include a final prompt after the last COMMAND, too.
			Useful to visualize the exit status of the last read
			COMMAND. This is the default.
    --no-trailing-prompt
			Do not include a final prompt after the last COMMAND.
			The exit status of the last read COMMAND will only be
			indicated by the exit status of this script (unless
			--worst-status is given).
    --emulate-prompt	Use the prompt emulation even when Bash (4.4+) supports
			the rendering of PS1.
    --worst-status	Return the highest exit status of all COMMANDS instead
			of the exit status of the last COMMAND.
    --comment|-c COMMENT
			Use / replace \! in PS1 with COMMENT instead of the
			default counter of executed COMMANDS.
HELPTEXT
}

isTrailingPrompt=t
isEmulatePrompt=t; [ "${BASH_VERSINFO:-}" ] && [ \( ${BASH_VERSINFO[0]} -eq 4 -a ${BASH_VERSINFO[1]} -ge 4 \) -o ${BASH_VERSINFO[0]} -gt 4 ] && isEmulatePrompt=
isWorstStatus=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--trailing-prompt)	shift; isTrailingPrompt=t;;
	--no-trailing-prompt)	shift; isTrailingPrompt=;;
	--emulate-prompt)	shift; isEmulatePrompt=t;;
	--worst-status)		shift; isWorstStatus=t;;
	--comment|-c)		shift; comment="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
[ $# -gt 0 ] && { printUsage "$0"; exit 2; }

if [ ! "$isEmulatePrompt" -a ! "$PS1" ]; then
    # The prompt isn't exported.
    if exists PS1Setup; then
	source PS1Setup
    elif callable PS1Setup; then
	PS1Setup
    fi
    [ "$PS1" ] || isEmulatePrompt=t
fi


: ${COLOR_RESET:='[0m'}
: ${COLOR_RUNWITHPROMPT_SUCCESS:='[00;35;47m'}
: ${COLOR_RUNWITHPROMPT_FAILURE:='[00;37;41m'}
: ${RUNWITHPROMPT_TIMESTAMP:=%d-%b-%Y %T}


timestamp()
{
    [ "$RUNWITHPROMPT_TIMESTAMP" ] && date "+$RUNWITHPROMPT_TIMESTAMP"
}

if [ "$isEmulatePrompt" ]; then
    exitStatusIndicator=
    exitColor=$COLOR_RUNWITHPROMPT_SUCCESS

    prompt()
    {
	if [ $exitStatus -eq 0 ]; then
	    exitStatusIndicator=; exitColor=$COLOR_RUNWITHPROMPT_SUCCESS
	else
	    exitStatusIndicator="(${exitStatus})"; exitColor=$COLOR_RUNWITHPROMPT_FAILURE
	fi

	timestamp=$(timestamp)
	printf "%s%-$((${COLUMNS:-80} - ${#timestamp} - 10))s %s %s %s\n$ %s\n" "$exitColor" "$exitStatusIndicator" "$timestamp" "${1:+!}${1:-  }" "$COLOR_RESET" "$command"
    }
else
    prompt()
    {
	local promptString="${PS1//\\!/${1:- }}"
	[ $exitStatus -eq 0 ]
	printf '%s%s\n' "${promptString@P}" "$command"
    }
fi

count=
exitStatus=0
overallExitStatus=0
while IFS=$'\n' read -r command
do
    prompt "${comment-$count}"

    eval "$command"
    exitStatus=$?

    if [ ! "$isWorstStatus" -o $exitStatus -gt $overallExitStatus ]; then
	overallExitStatus=$exitStatus
    fi

    let count+=1
done
[ "$isTrailingPrompt" ] && prompt "${comment-$count}"

exit $overallExitStatus
