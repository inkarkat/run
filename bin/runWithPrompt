#!/bin/bash

printShortUsage()
{
    printf 'Usage: echo COMMANDS | %q %s\n' "$(basename "$1")" '[--trailing-prompt|--no-trailing-prompt] [--emulate-prompt] [--worst-status] [-c|--comment COMMENT] [--summarize-failed ERROR-TEXT [--summarize-failed-separator SEP]] [-?|-h|--help]'
    printf 'Usage: %q %s <<EOF\n  COMMANDS\nEOF\n' "$(basename "$1")" '[...]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Run the COMMANDS read from stdin, each surrounded by an (emulated) command prompt.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --trailing-prompt	Include a final prompt after the last COMMAND, too.
			Useful to visualize the exit status of the last read
			COMMAND. This is the default.
    --no-trailing-prompt
			Do not include a final prompt after the last COMMAND.
			The exit status of the last read COMMAND will only be
			indicated by the exit status of this script (unless
			--worst-status is given).
    --emulate-prompt	Use the prompt emulation even when Bash (4.4+) supports
			the rendering of PS1.
    --worst-status	Return the highest exit status of all COMMANDS instead
			of the exit status of the last COMMAND.
    --comment|-c COMMENT
			Use / replace \! in PS1 with COMMENT instead of the
			default counter of executed COMMANDS.
			You can also update this within COMMANDS by setting the
			COMMENT=... variable. If you do this on a separate line
			with the form COMMENT='text' or COMMENT="text" or
			COMMENT=text, the update will happen silently; i.e.
			without printing that command-line.
    --summarize-failed ERROR-TEXT
			For each failed line in COMMANDS, record the counter /
			COMMENT and summarize those failures at the end (as a
			commented command in the trailing prompt, or just as a
			final line if --no-trailing-prompt) with
			ERROR-TEXT COMMENT1 COMMENT2 ...
    --summarize-failed-separator SEP
			Use SEP instead of a space in between COMMENT1 COMMENT2.
HELPTEXT
}

isTrailingPrompt=t
isEmulatePrompt=t; [ "${BASH_VERSINFO:-}" ] && [ \( ${BASH_VERSINFO[0]} -eq 4 -a ${BASH_VERSINFO[1]} -ge 4 \) -o ${BASH_VERSINFO[0]} -gt 4 ] && isEmulatePrompt=
isWorstStatus=
isSummarizeFailed=
summarizeFailedSeparator=' '
summarizeFailedPrefix=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--trailing-prompt)	shift; isTrailingPrompt=t;;
	--no-trailing-prompt)	shift; isTrailingPrompt=;;
	--emulate-prompt)	shift; isEmulatePrompt=t;;
	--worst-status)		shift; isWorstStatus=t;;
	--comment|-c)		shift; COMMENT="$1"; shift;;
	--summarize-failed)	shift; isSummarizeFailed=t; summarizeFailedPrefix="$1"; shift;;
	--summarize-failed-separator)	shift; summarizeFailedSeparator="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
[ $# -gt 0 ] && { printUsage "$0" >&2; exit 2; }

if [ ! "$isEmulatePrompt" -a ! "$PS1" ]; then
    # The prompt isn't exported.
    if exists PS1Setup; then
	source PS1Setup
    elif callable PS1Setup; then
	PS1Setup
    fi
    [ "$PS1" ] || isEmulatePrompt=t
fi


: ${COLOR_RESET:='[0m'}
: ${COLOR_RUNWITHPROMPT_SUCCESS:='[00;35;47m'}
: ${COLOR_RUNWITHPROMPT_FAILURE:='[00;37;41m'}
: ${RUNWITHPROMPT_TIMESTAMP:=%d-%b-%Y %T}


timestamp()
{
    [ "$RUNWITHPROMPT_TIMESTAMP" ] && date "+$RUNWITHPROMPT_TIMESTAMP"
}

if [ "$isEmulatePrompt" ]; then
    exitStatusIndicator=
    exitColor=$COLOR_RUNWITHPROMPT_SUCCESS

    prompt()
    {
	if [ $exitStatus -eq 0 ]; then
	    exitStatusIndicator=; exitColor=$COLOR_RUNWITHPROMPT_SUCCESS
	else
	    exitStatusIndicator="(${exitStatus})"; exitColor=$COLOR_RUNWITHPROMPT_FAILURE
	fi

	timestamp=$(timestamp)
	printf "%s%-$((${COLUMNS:-80} - ${#timestamp} - 10))s %s %s %s\n$ %s\n" "$exitColor" "$exitStatusIndicator" "$timestamp" "${1:+!}${1:-  }" "$COLOR_RESET" "$command"
    }
else
    prompt()
    {
	local promptString="${PS1//\\!/${1:- }}"
	[ $exitStatus -eq 0 ]
	printf '%s%s\n' "${promptString@P}" "$command"
    }
fi

originalColumns=${COLUMNS:=80}
adaptColumnsToFitLongComment()
{
    [ "$COMMENT" ] || return
    local commentLen=${#COMMENT}
    if [ $commentLen -gt 6 ]; then
	local newColumns=$((originalColumns - commentLen + 6))
	[ $newColumns -gt 25 -a $newColumns -lt $COLUMNS ] && COLUMNS=$newColumns
    fi
}

count=
exitStatus=0
overallExitStatus=0
summarizeFailures=
while IFS=$'\n' read -r command
do
    if  [[ "$command" =~ ^[[:space:]]*COMMENT=\"[^\"]*\"[[:space:]]*$ ]] || \
	[[ "$command" =~ ^[[:space:]]*COMMENT=\'[^\']*\'[[:space:]]*$ ]] || \
	[[ "$command" =~ ^[[:space:]]*COMMENT=[^\'\"\;\&\|]*[[:space:]]*$ ]]; then
	# This command solely sets the COMMENT; don't log it, just silently
	# execute it.
	eval "$command"
	continue
    fi

    adaptColumnsToFitLongComment; prompt "${COMMENT-$count}"

    eval "$command"
    exitStatus=$?

    [ $exitStatus -eq 0 ] || summarizeFailures="${summarizeFailures}${summarizeFailures:+$summarizeFailedSeparator}${COMMENT-$count}"
    if [ ! "$isWorstStatus" -o $exitStatus -gt $overallExitStatus ]; then
	overallExitStatus=$exitStatus
    fi

    let count+=1
done
if [ "$isTrailingPrompt" ]; then
    [ "$summarizeFailures" ] && command="# ${summarizeFailedPrefix}$summarizeFailures"

    adaptColumnsToFitLongComment
    prompt "${COMMENT-$count}"
else
    [ "$summarizeFailures" ] && printf >&2 '%s%s\n' "$summarizeFailedPrefix" "$summarizeFailures"
fi

exit $overallExitStatus
