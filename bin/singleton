#!/bin/bash
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-q|--quiet|-v|--verbose] -i|--id ID -c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Execute COMMAND unless another instance (that is protected by this wrapper,
identified via ID) is already running.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --quiet|-q	    Suppresses the default message if task execution should be
		    skipped.
    --verbose|-v    Comments on every outcome (also runs), not just those tasks
		    whose execution should be skipped.
    --command|-c "COMMANDLINE"
		    Execute COMMANDLINE(s).

EXIT STATUS:
    If COMMAND is passed, returns its exit status, or 99:
    99	Another instance of COMMAND is currently executing.
    2	Bad invocation, wrong or missing command-line arguments.
HELPTEXT
}

isQuiet=
isVerbose=
id=
escapedId=
isNeedEval=
typeset -a commands=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--quiet|-q)	shift; isQuiet=t;;
	--verbose|-v)	shift; isVerbose=t;;
	--id|-i)	shift; id="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	commands+=(${commands:+;} $(printf '%q ' "$@"))
    else
	commands=("$@")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
	echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
	exit 2
fi
[ "$id" ] || id="${commands[*]}"    # Generate ID from passed COMMAND(s).
escapedId="${id//	/ }"
singletonId=$$


marker()
{
    executionMarker --group singleton "$@"
}
getOwner()
{
    marker --query "$escapedId" --get-context
}
checkout()
{
    marker --update "$escapedId" --context "$singletonId"
}
checkin()
{
    marker --update "$escapedId" --context 0
}
execute()
{
    if [ "$isNeedEval" ]; then
	eval "${commands[@]}"
    else
	"${commands[@]}"
    fi
}
relativeTimeDiff()
{
    reldate --timespan "+${1:?}" 2>/dev/null || printf '%s\n' "${1:?}s ago"
}


owner="$(getOwner)"
isAbandoned=
if [ "$isVerbose" ]; then
    lastRun="$(marker --time "$escapedId" --format '')"
    timeDiff="$(marker --diff "$escapedId")"
fi
if [ "${owner:-0}" != 0 ] && ! ps -p "$owner" >/dev/null 2>&1; then
    isAbandoned=t
    owner=0
fi
if [ "${owner:-0}" = 0 ]; then
    checkout
    verifiedOwner="$(getOwner)"
    if [ "$verifiedOwner" = "$singletonId" ]; then
	if [ "$isVerbose" ]; then
	    if [ "$owner" ]; then
		if [ "$isAbandoned" ]; then
		    printf >&2 '%s had been running under PID %d since %s (%s), but that process does not exist any longer.\n' "$id" "$owner" "$lastRun" "$(relativeTimeDiff "$timeDiff")"
		else
		    printf >&2 '%s last ran %s (%s).\n' "$id" "$lastRun" "$(relativeTimeDiff "$timeDiff")"
		fi
	    else
		printf >&2 '%s never ran so far.\n' "$id"
	    fi
	fi

	trap "checkin" EXIT
	execute
	exit $?
    else
	owner="$verifiedOwner"
    fi
fi

if [ ! "$isQuiet" ]; then
    lastRun="$(marker --time "$escapedId" --format '')"
    timeDiff="$(marker --diff "$escapedId")"
    printf >&2 '%s has been running under PID %d since %s (%s).\n' "$id" "$owner" "$lastRun" "$(relativeTimeDiff "$timeDiff")"
fi
exit 99
